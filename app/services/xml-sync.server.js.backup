// /app/services/xml-sync.server.js
import { XMLParser } from "fast-xml-parser";
import { prisma } from "../db.server.js";

// Configuraci贸n de logging
const LOG_LEVELS = {
  ERROR: 'error',
  WARN: 'warn', 
  INFO: 'info',
  DEBUG: 'debug'
};

const currentLogLevel = process.env.NODE_ENV === 'development' ? LOG_LEVELS.DEBUG : LOG_LEVELS.WARN;

function log(level, message, data = null) {
  const logLevelOrder = {
    error: 0,
    warn: 1,
    info: 2,
    debug: 3
  };
  
  if (logLevelOrder[level] <= logLevelOrder[currentLogLevel]) {
    if (data && typeof data === 'object') {
      console[level](`[XML-SYNC] ${message}`, JSON.stringify(data, null, 2));
    } else if (data) {
      console[level](`[XML-SYNC] ${message}`, data);
    } else {
      console[level](`[XML-SYNC] ${message}`);
    }
  }
}

// Wrapper para GraphQL que maneja errores de forma limpia
async function safeGraphQLCall(admin, query, variables, operationName = 'GraphQL') {
  try {
    const response = await admin.graphql(query, { variables });
    const responseJson = await response.json();
    
    // Si hay errores de GraphQL, los manejamos sin imprimir el response completo
    if (responseJson.errors && responseJson.errors.length > 0) {
      const errorMessages = responseJson.errors.map(e => e.message);
    //   log(LOG_LEVELS.ERROR, `${operationName} GraphQL errors`, errorMessages);
      
      return {
        success: false,
        errors: responseJson.errors,
        data: null
      };
    }
    
    return {
      success: true,
      errors: [],
      data: responseJson.data
    };
    
  } catch (error) {
    // log(LOG_LEVELS.ERROR, `${operationName} failed`, error.message);
    return {
      success: false,
      errors: [{ message: error.message }],
      data: null
    };
  }
}

// Configuraci贸n del parser XML
const xmlParserConfig = {
  ignoreAttributes: false,
  attributeNamePrefix: "@_",
  textNodeName: "#text",
  parseAttributeValue: true,
  trimValues: true,
  removeNSPrefix: true, // Importante: esto elimina los prefijos de namespace como g:
  parseTagValue: false,
};

// Funci贸n para parsear productos del XML (reutilizada)
export function parseProductsFromXML(xmlContent) {
  const parser = new XMLParser(xmlParserConfig);

  try {
    const result = parser.parse(xmlContent);

    let products = [];
    
    // log(LOG_LEVELS.DEBUG, 'Estructura del XML parseado', Object.keys(result));
    
    // Detectar diferentes formatos de XML comunes
    if (result.products && result.products.product) {
      products = Array.isArray(result.products.product) 
        ? result.products.product 
        : [result.products.product];
    } else if (result.catalog && result.catalog.item) {
      products = Array.isArray(result.catalog.item) 
        ? result.catalog.item 
        : [result.catalog.item];
    } else if (result.rss && result.rss.channel && result.rss.channel.item) {
      products = Array.isArray(result.rss.channel.item) 
        ? result.rss.channel.item 
        : [result.rss.channel.item];
    } else if (result.feed && result.feed.entry) {
      // Google Shopping Feed format
      products = Array.isArray(result.feed.entry) 
        ? result.feed.entry 
        : [result.feed.entry];
    } else if (result.channel && result.channel.item) {
      // RSS format directo
      products = Array.isArray(result.channel.item) 
        ? result.channel.item 
        : [result.channel.item];
    } else if (result.item) {
      // Items directos (tu formato)
      products = Array.isArray(result.item) 
        ? result.item 
        : [result.item];
    } else if (result.product) {
      products = Array.isArray(result.product) 
        ? result.product 
        : [result.product];
    } else {
      // Buscar en todas las propiedades del objeto ra铆z
      for (const [key, value] of Object.entries(result)) {
        if (Array.isArray(value) && value.length > 0 && typeof value[0] === 'object') {
        //   log(LOG_LEVELS.INFO, `Encontrados productos en: ${key}`);
          products = value;
          break;
        } else if (typeof value === 'object' && value !== null) {
          // Buscar dentro de objetos anidados
          for (const [nestedKey, nestedValue] of Object.entries(value)) {
            if (Array.isArray(nestedValue) && nestedValue.length > 0 && typeof nestedValue[0] === 'object') {
            //   log(LOG_LEVELS.INFO, `Encontrados productos en: ${key}.${nestedKey}`);
              products = nestedValue;
              break;
            }
          }
          if (products.length > 0) break;
        }
      }
    }

    return products.map((product, index) => {
      // Debug: mostrar estructura de un producto
      if (index === 0) {
        // log(LOG_LEVELS.DEBUG, 'Estructura del primer producto', Object.keys(product));
      }

      // Extraer precio (considerando sale_price si est谩 disponible)
      let price = 0;
      const priceText = product.sale_price || product.price || product.cost || product.amount || '0';
      if (typeof priceText === 'string') {
        // Extraer n煤mero del string "179.00 EUR" -> 179.00
        const priceMatch = priceText.match(/[\d.]+/);
        price = priceMatch ? parseFloat(priceMatch[0]) : 0;
      } else {
        price = parseFloat(priceText) || 0;
      }

      return {
        // Google Shopping format: g:id se convierte en 'id' despu茅s del removeNSPrefix
        id: product.id || product["@_id"] || product.gtin || product.sku || `product-${index}`,
        title: product.title || product.name || product.description || `Producto ${index + 1}`,
        body_html: product.description || product.summary || product.title || '',
        price: price,
        sku: product.sku || product.id || product.gtin || product.code || null,
        vendor: product.brand || product.vendor || product.manufacturer || 'Proveedor XML',
        product_type: product.category || product.type || product.productType || 'General',
        tags: extractTags(product),
        images: extractImages(product),
        variants: extractVariants(product),
        // Campos adicionales espec铆ficos del formato Google Shopping
        condition: product.condition || 'new',
        availability: product.availability || 'in_stock',
        color: product.color || null,
        gtin: product.gtin || null,
        link: product.link || null,
        // Campos adicionales para tracking
        rawData: product, // Guardamos el producto original para comparaciones
      };
    });
  } catch (error) {
    throw new Error(`Error al parsear XML: ${error.message}`);
  }
}

// Funciones auxiliares actualizadas para Google Shopping format
export function extractImages(product) {
  const images = [];
  
  // Google Shopping format: image_link
  if (product.image_link) {
    images.push({ src: product.image_link });
  }
  
  // Formatos tradicionales
  if (product.image) {
    const imageUrls = Array.isArray(product.image) ? { src: product.image} : [{src: product.image}];
    images.push(...imageUrls);
  }
  
  if (product.images && product.images.image) {
    const imageUrls = Array.isArray(product.images.image) ? {src: product.images.image} : [{src: product.images.image}];
    images.push(...imageUrls);
  }
  
  // Filtrar URLs v谩lidas
  return images.filter(img => typeof img === 'string' && img.startsWith('http'));
}

export function extractTags(product) {
  const tags = [];
  
  // A帽adir campos como tags
  if (product.brand) tags.push(product.brand);
  if (product.color) tags.push(product.color);
  if (product.condition) tags.push(product.condition);
  if (product.category) tags.push(product.category);
  
  // Tags tradicionales
  if (product.tags) {
    if (Array.isArray(product.tags)) {
      tags.push(...product.tags);
    } else {
      tags.push(product.tags);
    }
  }
  
  if (product.categories) {
    if (Array.isArray(product.categories)) {
      tags.push(...product.categories);
    } else {
      tags.push(product.categories);
    }
  }
  
  return [...new Set(tags)]; // Eliminar duplicados
}

export function extractVariants(product) {
  if (product.variants && product.variants.variant) {
    const variants = Array.isArray(product.variants.variant) 
      ? product.variants.variant 
      : [product.variants.variant];
    
    return variants.map(variant => ({
      price: parseFloat(variant.price || product.price || '0') || 0,
      sku: variant.sku || variant.id || null,
      inventory: parseInt(variant.inventory || variant.stock || '0') || 0,
      option1: variant.size || variant.color || variant.option1 || null,
      option2: variant.color || variant.material || variant.option2 || null,
    }));
  }
  
  // Para Google Shopping format, crear una variante b谩sica
  let price = 0;
  const priceText = product.sale_price || product.price || product.cost || '0';
  if (typeof priceText === 'string') {
    const priceMatch = priceText.match(/[\d.]+/);
    price = priceMatch ? parseFloat(priceMatch[0]) : 0;
  } else {
    price = parseFloat(priceText) || 0;
  }

  // Determinar stock basado en availability
  let inventory = 0;
  if (product.availability === 'in_stock') {
    inventory = 99; // Stock por defecto para productos disponibles
  } else if (product.availability === 'out_of_stock') {
    inventory = 0;
  } else if (product.inventory || product.stock) {
    inventory = parseInt(product.inventory || product.stock || '0') || 0;
  }
  
  return [{
    price: price,
    sku: product.gtin || product.sku || product.id || null,
    inventory: inventory,
    option1: product.color || null,
    option2: product.condition || null,
  }];
}

// Funci贸n para sincronizar un proveedor espec铆fico
export async function syncProvider(admin, providerId) {
  const syncStart = new Date();
  let syncLog;

  try {
    // Obtener informaci贸n del proveedor
    const provider = await prisma.xmlProvider.findUnique({
      where: { id: providerId },
      include: { products: true }
    });

    if (!provider || !provider.isActive) {
      throw new Error("Proveedor no encontrado o inactivo");
    }

    // Crear log de sincronizaci贸n
    syncLog = await prisma.syncLog.create({
      data: {
        providerId,
        status: 'running',
        startedAt: syncStart,
      }
    });

    // Descargar XML
    const response = await fetch(provider.xmlUrl, {
      method: 'GET',
      headers: {
        'Accept': 'application/xml, text/xml, */*',
        'User-Agent': 'Lector-XML-Proveedor/1.0',
      },
    });

    if (!response.ok) {
      throw new Error(`Error HTTP: ${response.status} ${response.statusText}`);
    }

    const xmlContent = await response.text();
    const parsedProducts = parseProductsFromXML(xmlContent);

    // Mapear productos existentes por XML ID
    const existingProducts = new Map(
      provider.products.map(p => [p.xmlProductId, p])
    );

    // Crear Set de IDs de productos del XML actual
    const currentXmlProductIds = new Set(parsedProducts.map(p => p.id));

    const results = {
      created: [],
      updated: [],
      deleted: [],
      errors: []
    };

    // Procesar cada producto
    for (const xmlProduct of parsedProducts.slice(0, 20)) { // L铆mite de 20 productos por sync
      try {
        const existingProduct = existingProducts.get(xmlProduct.id);

        if (existingProduct) {
          // ACTUALIZAR producto existente
          const updateResult = await updateShopifyProduct(admin, existingProduct, xmlProduct);
          if (updateResult.success) {
            results.updated.push(updateResult.product);
            
            // Actualizar mapping en BD
            await prisma.productMapping.update({
              where: { id: existingProduct.id },
              data: {
                title: xmlProduct.title,
                lastPrice: xmlProduct.price,
                lastUpdated: new Date(),
                lastSeenInXml: new Date(),
              }
            });
          } else {
            results.errors.push({ product: xmlProduct.title, error: updateResult.error });
          }
        } else {
          // CREAR nuevo producto
          const createResult = await createShopifyProduct(admin, xmlProduct);
          if (createResult.success) {
            results.created.push(createResult.product);
            
            // Crear mapping en BD
            await prisma.productMapping.create({
              data: {
                providerId,
                xmlProductId: xmlProduct.id,
                xmlSku: xmlProduct.sku,
                shopifyProductId: createResult.product.id,
                shopifyHandle: createResult.product.handle,
                title: xmlProduct.title,
                lastPrice: xmlProduct.price,
                lastSeenInXml: new Date(),
              }
            });
          } else {
            results.errors.push({ product: xmlProduct.title, error: createResult.error });
          }
        }
      } catch (error) {
        results.errors.push({ product: xmlProduct.title, error: error.message });
      }
    }

    // ELIMINAR productos que ya no est谩n en el XML (solo si autoDelete est谩 habilitado)
    let productsToDelete = [];
    if (provider.autoDelete) {
      productsToDelete = provider.products.filter(p => 
        p.isActive && !currentXmlProductIds.has(p.xmlProductId)
      );
    }

    for (const productToDelete of productsToDelete) {
      try {
        // Eliminar producto de Shopify
        const deleteResult = await deleteShopifyProduct(admin, productToDelete);
        if (deleteResult.success) {
          results.deleted.push({
            id: productToDelete.shopifyProductId,
            title: productToDelete.title,
            xmlProductId: productToDelete.xmlProductId
          });
          
          // Marcar como inactivo en la BD (no eliminar el registro para historial)
          await prisma.productMapping.update({
            where: { id: productToDelete.id },
            data: {
              isActive: false,
              lastUpdated: new Date(),
            }
          });
        } else {
          results.errors.push({ 
            product: productToDelete.title, 
            error: `Error al eliminar: ${deleteResult.error}` 
          });
        }
      } catch (error) {
        results.errors.push({ 
          product: productToDelete.title, 
          error: `Error al eliminar: ${error.message}` 
        });
      }
    }

    // Actualizar provider con pr贸xima sincronizaci贸n
    const nextSync = new Date(syncStart.getTime() + (provider.syncFrequency * 60 * 60 * 1000));
    await prisma.xmlProvider.update({
      where: { id: providerId },
      data: {
        lastSync: syncStart,
        nextSync: nextSync,
      }
    });

    // Finalizar log de sincronizaci贸n
    const syncEnd = new Date();
    await prisma.syncLog.update({
      where: { id: syncLog.id },
      data: {
        status: results.errors.length === 0 ? 'success' : (results.created.length > 0 || results.updated.length > 0 || results.deleted.length > 0 ? 'partial' : 'error'),
        totalProducts: parsedProducts.length,
        productsCreated: results.created.length,
        productsUpdated: results.updated.length,
        productsDeleted: results.deleted.length,
        productsErrors: results.errors.length,
        details: JSON.stringify(results),
        completedAt: syncEnd,
        duration: Math.round((syncEnd.getTime() - syncStart.getTime()) / 1000),
      }
    });

    return {
      success: true,
      results,
      totalProducts: parsedProducts.length,
      nextSync: nextSync,
    };

  } catch (error) {
    // Actualizar log con error
    if (syncLog) {
      await prisma.syncLog.update({
        where: { id: syncLog.id },
        data: {
          status: 'error',
          errorMessage: error.message,
          completedAt: new Date(),
          duration: Math.round((new Date().getTime() - syncStart.getTime()) / 1000),
        }
      });
    }

    throw error;
  }
}

// Funci贸n para crear un producto en Shopify
export async function createShopifyProduct(admin, xmlProduct) {
  try {
    // Crear el producto b谩sico primero (sin variants ni images)
    const shopifyProduct = {
      title: xmlProduct.title,
      descriptionHtml: xmlProduct.description,
      vendor: xmlProduct.vendor,
      productType: xmlProduct.productType,
      tags: Array.isArray(xmlProduct.tags) ? xmlProduct.tags.join(', ') : xmlProduct.tags,
    };

    const result = await safeGraphQLCall(
      admin,
      `#graphql
      mutation productCreate($product: ProductCreateInput!) {
        productCreate(product: $product) {
          product {
            # id
            title
            handle
            status
            variants(first: 1) {
              edges {
                node {
                  id
                }
              }
            }
          }
          userErrors {
            field
            message
          }
        }
      }`,
      { product: shopifyProduct },
      `Crear producto ${xmlProduct.title}`
    );

    if (!result.success) {
      return {
        success: false,
        error: result.errors.map(e => e.message).join(', ')
      };
    }
    
    if (result.data.productCreate.userErrors.length > 0) {
    //   log(LOG_LEVELS.WARN, `User errors para producto ${xmlProduct.title}`, result.data.productCreate.userErrors.map(e => e.message));
      return {
        success: false,
        error: result.data.productCreate.userErrors.map(e => e.message).join(', ')
      };
    }

    const createdProduct = result.data.productCreate.product;

    // Actualizar la primera variante con precio y SKU
    if (xmlProduct.variants.length > 0 && createdProduct.variants.edges.length > 0) {
      const variantId = createdProduct.variants.edges[0].node.id;
      const firstVariant = xmlProduct.variants[0];

      const variantResult = await safeGraphQLCall(
        admin,
        `#graphql
        mutation productVariantsBulkUpdate($productId: ID!, $variants: [ProductVariantsBulkInput!]!) {
          productVariantsBulkUpdate(productId: $productId, variants: $variants) {
            productVariants {
              id
              price
              sku
            }
            userErrors {
              field
              message
            }
          }
        }`,
        {
          productId: createdProduct.id,
          variants: [{
            id: variantId,
            price: firstVariant.price.toString(),
            sku: firstVariant.sku,
          }]
        },
        `Actualizar variante de ${xmlProduct.title}`
      );

      if (!variantResult.success) {
        // log(LOG_LEVELS.WARN, `No se pudo actualizar la variante para ${xmlProduct.title}`, variantResult.errors.map(e => e.message));
      }
    }

    // Por ahora omitimos las im谩genes para evitar complejidades con la API
    // Las im谩genes se pueden a帽adir manualmente o en una versi贸n futura
    if (xmlProduct.images.length > 0) {
    //   console.log(`Producto ${createdProduct.title} tiene ${xmlProduct.images.length} im谩genes disponibles:`, xmlProduct.images.slice(0, 3));
    }

    return {
      success: true,
      product: createdProduct
    };
  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }
}

// Funci贸n para actualizar un producto en Shopify
export async function updateShopifyProduct(admin, existingMapping, xmlProduct) {
  try {
    // Verificar si necesita actualizaci贸n (precio cambi贸)
    if (existingMapping.lastPrice === xmlProduct.price) {
      return {
        success: true,
        product: { id: existingMapping.shopifyProductId, title: xmlProduct.title },
        updated: false
      };
    }

    const result = await safeGraphQLCall(
      admin,
      `#graphql
      mutation productUpdate($product: ProductUpdateInput!) {
        productUpdate(product: $product) {
          product {
            id
            title
            handle
          }
          userErrors {
            field
            message
          }
        }
      }`,
      {
        product: {
          id: existingMapping.shopifyProductId,
          title: xmlProduct.title,
          descriptionHtml: xmlProduct.description,
          vendor: xmlProduct.vendor,
          productType: xmlProduct.productType,
        }
      },
      `Actualizar producto ${xmlProduct.title}`
    );

    if (!result.success) {
      return {
        success: false,
        error: result.errors.map(e => e.message).join(', ')
      };
    }
    
    if (result.data.productUpdate.userErrors.length > 0) {
    //   log(LOG_LEVELS.WARN, `User errors para actualizaci贸n de producto ${xmlProduct.title}`, result.data.productUpdate.userErrors.map(e => e.message));
      return {
        success: false,
        error: result.data.productUpdate.userErrors.map(e => e.message).join(', ')
      };
    }

    return {
      success: true,
      product: result.data.productUpdate.product,
      updated: true
    };
  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }
}

// Funci贸n para eliminar un producto de Shopify
async function deleteShopifyProduct(admin, productMapping) {
  try {
    const result = await safeGraphQLCall(
      admin,
      `#graphql
      mutation productDelete($input: ProductDeleteInput!) {
        productDelete(input: $input) {
          deletedProductId
          userErrors {
            field
            message
          }
        }
      }`,
      {
        input: {
          id: productMapping.shopifyProductId
        }
      },
      `Eliminar producto ${productMapping.title}`
    );

    if (!result.success) {
      return {
        success: false,
        error: result.errors.map(e => e.message).join(', ')
      };
    }
    
    if (result.data.productDelete.userErrors.length > 0) {
    //   log(LOG_LEVELS.WARN, `User errors para eliminaci贸n de producto ${productMapping.title}`, result.data.productDelete.userErrors.map(e => e.message));
      return {
        success: false,
        error: result.data.productDelete.userErrors.map(e => e.message).join(', ')
      };
    }

    return {
      success: true,
      deletedProductId: result.data.productDelete.deletedProductId
    };
  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }
}

// Funci贸n para obtener proveedores que necesitan sincronizaci贸n
export async function getProvidersToSync(shop) {
  const now = new Date();
  
  return await prisma.xmlProvider.findMany({
    where: {
      shop,
      isActive: true,
      OR: [
        { nextSync: { lte: now } },
        { nextSync: null }
      ]
    },
    include: {
      products: true,
      syncLogs: {
        orderBy: { startedAt: 'desc' },
        take: 1
      }
    }
  });
}

// Funci贸n para buscar productos existentes en Shopify
export async function findExistingShopifyProduct(admin, xmlProduct) {
  try {
    // Buscar por SKU primero (m谩s confiable)
    if (xmlProduct.sku) {
      const response = await admin.graphql(`
        query findProductBySku($query: String!) {
          products(first: 1, query: $query) {
            edges {
              node {
                id
                title
                handle
                variants(first: 1) {
                  edges {
                    node {
                      id
                      sku
                    }
                  }
                }
              }
            }
          }
        }
      `, {
        variables: {
          query: `sku:${xmlProduct.sku}`
        }
      });

      const result = await response.json();
      if (result.data?.products?.edges?.length > 0) {
        return result.data.products.edges[0].node;
      }
    }

    log('info', 'El XML Product no se encontr贸 por SKU, intentando por ID o t铆tulo', { title: xmlProduct.title, sku: xmlProduct.sku, id: xmlProduct.id });

    // Si no se encontr贸 por SKU, buscar por ID del XML
    if (xmlProduct.id && xmlProduct.id !== xmlProduct.sku) {
      const idResponse = await admin.graphql(`
        query findProductById($query: String!) {
          products(first: 1, query: $query) {
            edges {
              node {
                id
                title
                handle
                variants(first: 1) {
                  edges {
                    node {
                      id
                      sku
                    }
                  }
                }
              }
            }
          }
        }
      `, {
        variables: {
          query: `id:${xmlProduct.id}`
        }
      });

      const idResult = await idResponse.json();
      if (idResult.data?.products?.edges?.length > 0) {
        return idResult.data.products.edges[0].node;
      }
    }

    // Si no se encontr贸 por SKU ni ID, buscar por t铆tulo exacto
    const titleQuery = xmlProduct.title.replace(/['"]/g, '').trim();
    const response = await admin.graphql(`
      query findProductByTitle($query: String!) {
        products(first: 1, query: $query) {
          edges {
            node {
              id
              title
              handle
              variants(first: 1) {
                edges {
                  node {
                    id
                    sku
                  }
                }
              }
            }
          }
        }
      }
    `, {
      variables: {
        query: `title:"${titleQuery}"`
      }
    });

    const titleResult = await response.json();
    if (titleResult.data?.products?.edges?.length > 0) {
      return titleResult.data.products.edges[0].node;
    }

    return null;
  } catch (error) {
    // log('error', `Error buscando producto existente para ${xmlProduct.title}:`, error.message);
    return null;
  }
}

// Funci贸n simplificada para procesar productos por lotes
export async function processProductsWithDuplicateCheck(admin, products, batchSize = 50) {
  console.log(` Iniciando procesamiento: ${products.length} productos en lotes de ${batchSize}`);
  
  const stats = {
    created: 0,
    updated: 0,
    errors: 0,
    duplicates: 0
  };
  
  const results = [];
  const errors = [];
  const updated = [];
  const processedIds = new Set(); // Evitar duplicados por ID y SKU
  
  // Procesar en lotes
  for (let i = 0; i < products.length; i += batchSize) {
    const batch = products.slice(i, i + batchSize);
    const batchNum = Math.floor(i / batchSize) + 1;
    const totalBatches = Math.ceil(products.length / batchSize);
    
    console.log(` Lote ${batchNum}/${totalBatches}: procesando ${batch.length} productos`);
    
    for (const product of batch) {
      try {
        // 1. Verificar duplicados
        if (isDuplicate(product, processedIds)) {
          stats.duplicates++;
          errors.push({ 
            product: product.title, 
            errors: [{ message: `Producto duplicado: ${product.id}` }] 
          });
          continue;
        }
        
        // 2. Marcar como procesado
        markAsProcessed(product, processedIds);
        
        // 3. Verificar si existe en Shopify
        const existingProduct = await findExistingShopifyProduct(admin, product);
        
        if (existingProduct) {
          // ACTUALIZAR producto existente
          const updateResult = await updateExistingProduct(admin, existingProduct, product);
          if (updateResult.success) {
            stats.updated++;
            updated.push(updateResult.product);
          } else {
            stats.errors++;
            errors.push({ product: product.title, errors: updateResult.errors });
          }
        } else {
          // CREAR nuevo producto
          const createResult = await createShopifyProduct(admin, product);
          if (createResult.success) {
            stats.created++;
            results.push(createResult.product);
          } else {
            stats.errors++;
            errors.push({ product: product.title, errors: [{ message: createResult.error }] });
          }
        }
          log('info', `Producto existente encontrado: ${existingProduct.title} - Actualizando...`);
          
          // Actualizar usando REST API para mayor control
          const numericProductId = existingProduct.id.split('/').pop();
          
          try {
            const productToUpdate = new admin.rest.Product({ session: admin.session });
            productToUpdate.id = parseInt(numericProductId);
            
            // Actualizar campos b谩sicos del producto
            productToUpdate.title = xmlProduct.title;
            productToUpdate.body_html = xmlProduct.body_html || xmlProduct.description;
            productToUpdate.vendor = xmlProduct.vendor;
            productToUpdate.tags = Array.isArray(xmlProduct.tags) ? xmlProduct.tags.join(', ') : xmlProduct.tags;
            
            await productToUpdate.save();
            
            // Actualizar variante si existe
            if (xmlProduct.variants?.length > 0 && existingProduct.variants?.edges?.length > 0) {
              const variantId = existingProduct.variants.edges[0].node.id.split('/').pop();
              const variantToUpdate = new admin.rest.Variant({ session: admin.session });
              
              variantToUpdate.id = parseInt(variantId);
              variantToUpdate.price = xmlProduct.variants[0].price;
              if (xmlProduct.variants[0].sku) {
                variantToUpdate.sku = xmlProduct.variants[0].sku;
              }
              
              await variantToUpdate.save();
            }
            
            updated.push({
              id: existingProduct.id,
              title: xmlProduct.title,
              action: 'updated'
            });
            
          } catch (updateError) {
            log('error', `Error actualizando producto ${xmlProduct.title}:`, updateError.message);
            errors.push({
              product: xmlProduct.title,
              errors: [{ message: `Error actualizando: ${updateError.message}` }]
            });
          }
          
        } else {
          // CREAR nuevo producto
          log('info', `Creando nuevo producto: ${xmlProduct.title}`);
          
          const createResult = await createShopifyProduct(admin, xmlProduct);
          if (createResult.success) {
            results.push(createResult.product);
            // Registrar el producto creado para evitar duplicados futuros
            createdProductIds.set(xmlProduct.id, createResult.product.id);
            log('info', `Producto creado exitosamente: ${createResult.product.title} (ID: ${createResult.product.id})`);
          } else {
            errors.push({
              product: xmlProduct.title,
              errors: [{ message: createResult.error }]
            });
          }
        }
        
      } catch (error) {
        log('error', `Error procesando producto ${xmlProduct.title}:`, error.message);
        errors.push({
          product: xmlProduct.title,
          errors: [{ message: error.message }]
        });
      }
    }
    
    // Log de progreso del lote
    log('info', `Lote ${batchNumber}/${totalBatches} completado - Creados en este lote: ${results.length - (batchStart / batchSize * results.length)}, Total acumulado: Creados ${results.length}, Actualizados ${updated.length}, Errores ${errors.length}`);
    
    // Peque帽a pausa entre lotes para evitar sobrecargar la API
    if (i + batchSize < totalProducts) {
      await new Promise(resolve => setTimeout(resolve, 1000)); // 1 segundo de pausa
    }
  }

  // Log de resumen final
  log('info', `Procesamiento completado - Total: Creados ${results.length}, Actualizados ${updated.length}, Errores ${errors.length}, Duplicados evitados ${processedIds.size - results.length - updated.length}`);

  return { 
    results, 
    errors, 
    updated,
    created: results.length,
    updatedCount: updated.length,
    totalProcessed: processedIds.size,
    duplicatesSkipped: processedIds.size - results.length - updated.length
  };
}

// Funci贸n para procesar productos con reportes de progreso en tiempo real
export async function processProductsWithProgressReporting(admin, products, batchSize = 50, sendEvent) {
  const totalProducts = products.length;
  const results = [];
  const errors = [];
  const updated = [];
  
  // Cache global para evitar duplicados por ID y SKU durante toda la importaci贸n
  const processedIds = new Set();
  const createdProductIds = new Map();
  
  log('info', `Iniciando procesamiento con progreso: ${totalProducts} productos total, ${batchSize} por lote`);
  
  // Procesar en lotes
  for (let i = 0; i < totalProducts; i += batchSize) {
    const batchStart = i;
    const batchEnd = Math.min(i + batchSize, totalProducts);
    const currentBatch = products.slice(batchStart, batchEnd);
    const batchNumber = Math.floor(i / batchSize) + 1;
    const totalBatches = Math.ceil(totalProducts / batchSize);
    
    // Enviar progreso del lote
    sendEvent('batchStarted', {
      batchNumber,
      totalBatches,
      batchStart: batchStart + 1,
      batchEnd,
      progress: Math.round((i / totalProducts) * 100)
    });
    
    const batchResults = [];
    const batchUpdated = [];
    const batchErrors = [];
    
    // Procesar cada producto del lote actual
    for (let j = 0; j < currentBatch.length; j++) {
      const xmlProduct = currentBatch[j];
      const productIndex = batchStart + j + 1;
      
      try {
        // Verificar duplicados usando tanto ID como SKU/GTIN
        const productKey = xmlProduct.id;
        const productSku = xmlProduct.sku || xmlProduct.gtin;
        
        if (processedIds.has(productKey) || (productSku && processedIds.has(productSku))) {
          const error = {
            product: xmlProduct.title,
            errors: [{ message: `Producto duplicado (ID: ${productKey} o SKU: ${productSku}), ignorado` }]
          };
          batchErrors.push(error);
          errors.push(error);
          continue;
        }
        
        // Marcar como procesado
        processedIds.add(productKey);
        if (productSku) {
          processedIds.add(productSku);
        }
        
        // Buscar si el producto ya existe en Shopify
        const existingProduct = await findExistingShopifyProduct(admin, xmlProduct);
        
        if (existingProduct) {
          // ACTUALIZAR producto existente
          const numericProductId = existingProduct.id.split('/').pop();
          
          try {
            const productToUpdate = new admin.rest.Product({ session: admin.session });
            productToUpdate.id = parseInt(numericProductId);
            
            productToUpdate.title = xmlProduct.title;
            productToUpdate.body_html = xmlProduct.body_html || xmlProduct.description;
            productToUpdate.vendor = xmlProduct.vendor;
            productToUpdate.tags = Array.isArray(xmlProduct.tags) ? xmlProduct.tags.join(', ') : xmlProduct.tags;
            
            await productToUpdate.save();
            
            // Actualizar variante si existe
            if (xmlProduct.variants?.length > 0 && existingProduct.variants?.edges?.length > 0) {
              const variantId = existingProduct.variants.edges[0].node.id.split('/').pop();
              const variantToUpdate = new admin.rest.Variant({ session: admin.session });
              
              variantToUpdate.id = parseInt(variantId);
              variantToUpdate.price = xmlProduct.variants[0].price;
              if (xmlProduct.variants[0].sku) {
                variantToUpdate.sku = xmlProduct.variants[0].sku;
              }
              
              await variantToUpdate.save();
            }
            
            const updatedProduct = {
              id: existingProduct.id,
              title: xmlProduct.title,
              action: 'updated',
              price: xmlProduct.price
            };
            
            batchUpdated.push(updatedProduct);
            updated.push(updatedProduct);
            
            // Enviar progreso del producto actualizado
            sendEvent('productProcessed', {
              productIndex,
              totalProducts,
              product: updatedProduct,
              action: 'updated'
            });
            
          } catch (updateError) {
            const error = {
              product: xmlProduct.title,
              errors: [{ message: `Error actualizando: ${updateError.message}` }]
            };
            batchErrors.push(error);
            errors.push(error);
          }
          
        } else {
          // CREAR nuevo producto
          const createResult = await createShopifyProduct(admin, xmlProduct);
          if (createResult.success) {
            const newProduct = {
              ...createResult.product,
              price: xmlProduct.price,
              action: 'created'
            };
            
            batchResults.push(newProduct);
            results.push(newProduct);
            createdProductIds.set(xmlProduct.id, createResult.product.id);
            
            // Enviar progreso del producto creado
            sendEvent('productProcessed', {
              productIndex,
              totalProducts,
              product: newProduct,
              action: 'created'
            });
            
          } else {
            const error = {
              product: xmlProduct.title,
              errors: [{ message: createResult.error }]
            };
            batchErrors.push(error);
            errors.push(error);
          }
        }
        
      } catch (error) {
        const errorObj = {
          product: xmlProduct.title,
          errors: [{ message: error.message }]
        };
        batchErrors.push(errorObj);
        errors.push(errorObj);
      }
    }
    
    // Enviar resumen del lote completado
    sendEvent('batchCompleted', {
      batchNumber,
      totalBatches,
      batchResults: batchResults.length,
      batchUpdated: batchUpdated.length,
      batchErrors: batchErrors.length,
      totalCreated: results.length,
      totalUpdated: updated.length,
      totalErrors: errors.length,
      progress: Math.round(((i + batchSize) / totalProducts) * 100)
    });
    
    // Peque帽a pausa entre lotes para evitar sobrecargar la API
    if (i + batchSize < totalProducts) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }

  // Resultado final
  const finalResult = {
    results, 
    errors, 
    updated,
    created: results.length,
    updatedCount: updated.length,
    totalProcessed: processedIds.size,
    duplicatesSkipped: processedIds.size - results.length - updated.length,
    totalProducts
  };

  log('info', `Procesamiento con progreso completado - Total: Creados ${results.length}, Actualizados ${updated.length}, Errores ${errors.length}`);

  return finalResult;
}

// Funci贸n para descargar y parsear XML desde una URL (para importaci贸n manual)
export async function parseXMLData(xmlUrl) {
  log(LOG_LEVELS.INFO, `Descargando XML desde: ${xmlUrl}`);
  
  const response = await fetch(xmlUrl, {
    method: 'GET',
    headers: {
      'Accept': 'application/xml, text/xml, */*',
      'User-Agent': 'Lector-XML-Proveedor/1.0',
    },
  });

  if (!response.ok) {
    throw new Error(`Error al descargar XML: ${response.status} ${response.statusText}`);
  }

  const xmlContent = await response.text();
  log(LOG_LEVELS.INFO, `XML descargado exitosamente, tama帽o: ${xmlContent.length} caracteres`);
  
  // Parsear el contenido XML usando la funci贸n existente
  const products = parseProductsFromXML(xmlContent);
  
  log(LOG_LEVELS.INFO, `Productos parseados: ${products.length}`);
  return products;
}